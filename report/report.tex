\documentclass[11pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{array}
\usepackage[colorlinks=true, linkcolor=black, urlcolor=blue, citecolor=black]{hyperref}
\usepackage{fancyhdr}
\usepackage{caption}
\usepackage{booktabs}
\usepackage{ragged2e}
\usepackage{enumitem}
\usepackage{amsmath, amssymb, booktabs}
\usepackage{siunitx}
\usepackage{multicol}
\usepackage{rotating}
\usepackage{tikz}
\usepackage{float}


% Arial-like font
\renewcommand{\familydefault}{\sfdefault}

% Page geometry
\geometry{
  a4paper,
  left=2.5cm,
  right=3.0cm,
  top=2.5cm,
  bottom=2.0cm
}

% Font and spacing
\onehalfspacing
\renewcommand{\familydefault}{\sfdefault}

% Title page
\begin{document}

\begin{titlepage}
\centering
% \vspace*{2cm}
  
\includegraphics[width=0.7\textwidth]{imgs/USB.png}\\[1cm]

\vspace{1.5cm}

\textbf{\Large University of South Bohemia} \\
\textbf{\large Faculty of Science} \\
\large Artificial Intelligence and Data Science, M.Sc. \\[2.5cm]

{\Large \textsc{Designing a Bloom Filter for a Target False Positive Rate}}\\[0.5cm]

Submitted for the course \textbf{Information Theory} \\
\textbf{Professor:} Kaštovský Jan prof. RNDr. Ph.D. \\[3cm]

\begin{flushleft}
\begin{tabular}{ll}
Submitted by: & María Isabel Sánchez-O'Mullony Martínez \\
Student ID: & B24763 \\
Date: & \today \\
\end{tabular}
\end{flushleft}

\vspace{3cm}

\begin{flushright}
\begin{tabular}{ll}
Supervisor: & Kaštovský Jan prof. RNDr. Ph.D. \\
\end{tabular}
\end{flushright}

\end{titlepage}


% ===============================
% Declaration
% ===============================
\section*{Declaration}
I declare that I have written this report by myself and have only used the sources and aids mentioned, and that I have 
marked direct and indirect citations as such. This report has not been submitted prior for any other examination.

I agree that the results of this study work / report may be used free of charge for research and lecturing purposes.

\newpage

% Table of Contents
\tableofcontents
\newpage

% List of Abbreviations
\section*{List of Abbreviations}
\begin{tabular}{ll}
    BF & Bloom Filter \\
    FPR & False-Positive Rate \\
\end{tabular}

\newpage

% Main Report Sections
% ===============================
% Introduction
% ===============================
\section{Introduction}\label{sec:Introduction}
A Bloom filter (BF)  is a simple, space-efficient, randomized data structure for concisely representing a static data 
set, in order to support approximate membership queries~\cite{guo2006theory}. It is mainly a spaced optimized version 
of hashing where we may have false positives. The idea is to not store the actual key rather store only hash values. 
It is mainly a probabilistic and space optimized hashing where less than 10 bits per key are required for a 1\% false 
positive probability and is not dependent on the size of individual keys~\cite{geeksforgeeks_bloom_filters}.

The structure has some interesting properties: 
It offers a compact probabilistic way to represent a set that can result in false positives (claiming an element to 
be part of the set when it is not), but never in false negatives (reporting an inserted element to be absent from 
the set). A Bloom filter of a fixed size can represent a set with an arbitrary large number of elements. Adding an 
element never fails, however, we need to take into account the increasing probability of false positive
~\cite{geeksforgeeks_bloom_filters, tarkoma2011theory}.

The tradeoff is that in exchange for providing a sometimes incorrect false positive answer, a bloom filter consumes a 
lot less memory than other data structures, like a hash table, and it is much faster. Another key point, is that is 
not possible to remove an item from the Bloom filter.

The objective of this project is to design and implement a Bloom filter that automatically chooses the optimal size 
($m$) and number of hash functions ($k$) to achieve a target false-positive rate (FPR) ($p$), given an expected number 
of elements ($n$).


% ===============================
% Algorithm Description
% ===============================
\section{Algorithm Description}\label{sec:Algorithm}
Bloom Filter has two oeprations, insert data and key lookup. It uses a bit array and hashing techniques to store the 
existence of a string. 

A BF for representing a set $S = \{x_1, \ldots, x_n\}$ of $n$ items is described by a vector of $m$ bits, initially 
all set to 0. The key idea is to use k hash functions, $h_i(x),1 \leq i \leq k$ to map items $x \in S$ to random 
numbers uniform in the range $1, \ldots, m$, where the hash functions are assumed to be uniform~\cite{tarkoma2011theory}.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{imgs/overview.png}
    \caption{Overview of a Bloom Filter~\cite{tarkoma2011theory}.}\label{fig:overview}
\end{figure}

To insert data in the BF, we first need a big bit array initialized to 0 and multiple hash functions which will take
the data and convert it into a unique number that points to a specific switch in the array. When we add the new item
into the filter we feed its name thorugh the hash functions and each function points to a switch in the array, turning
the switches to 1~\cite{yt2024bloom}.

To search for an item, the hash function is used again, checking if the corresponding switches in the array are 1. If 
there is even one that is 0, then the item id for sure not part of the set. However, there is the possibility that even
though all the switches are 1, the item might not be part of the set, this is a false positive.


% ===============================
% Implementation
% ===============================
\section{Implementation}\label{sec:Implementation}
The implementation was written in Python.

To design a Bloom filter for a specific FPR, you primarily compute m and k using the formulas above based on your 
expected n and target p. Properly tuning these parameters ensures your Bloom filter maintains your desired false 
positive rate.

1. Use the calculated m and k parameters.

2. Select hash functions that are independent and distribute uniformly over the bit array.

3. Be aware that increasing m (more bits) reduces FPR but increases memory consumption.

4. Adjust parameters if your element estimate n or FPR requirement changes.

\newpage

\cleardoublepage
\addcontentsline{toc}{section}{References}
\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
